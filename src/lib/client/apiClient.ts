/* eslint-disable */
/**
 * This file was automatically generated by pytauri-gen-ts.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source commands API,
 * and run pytauri-gen-ts to regenerate this file.
 */

import { pyInvoke } from "tauri-plugin-pytauri-api";
import type { InvokeOptions } from "@tauri-apps/api/core";

import type { Commands } from "./_apiTypes.d.ts";

/**
 * Get processed activities with optional date filtering.
 *
 * @param body - Request parameters including limit, offset, start, end.
 * @returns Activities data with success flag and timestamp
 */
export async function getActivities(
    body: Commands["get_activities"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_activities"]["output"]> {
    return await pyInvoke("get_activities", body, options);
}

/**
 * Get activity details by ID with full event summaries and records.
 *
 * @param body - Request parameters including activity ID.
 * @returns Activity details with success flag and timestamp
 */
export async function getActivityById(
    body: Commands["get_activity_by_id"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_activity_by_id"]["output"]> {
    return await pyInvoke("get_activity_by_id", body, options);
}

/**
 * Get incremental activity updates based on version negotiation.
 *
 * This handler implements version-based incremental updates. The client provides
 * its current version number, and the server returns only activities created or
 * updated after that version.
 *
 * @param body - Request parameters including client version and limit.
 * @returns New activities data with success flag, max version, and timestamp
 */
export async function getActivitiesIncremental(
    body: Commands["get_activities_incremental"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_activities_incremental"]["output"]> {
    return await pyInvoke("get_activities_incremental", body, options);
}

/**
 * Get activity count for each date (total count, not paginated).
 *
 * Returns the total number of activities for each date in the database.
 *
 * @param body - Request parameters (empty).
 * @returns Activity count statistics by date
 */
export async function getActivityCountByDate(
    body: Commands["get_activity_count_by_date"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_activity_count_by_date"]["output"]> {
    return await pyInvoke("get_activity_count_by_date", body, options);
}

/**
 * Get all events for a specific activity
 *
 * Args:
 *     body: Request containing activity_id
 *
 * Returns:
 *     Response with list of events
 */
export async function getEventsByActivity(
    body: Commands["get_events_by_activity"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_events_by_activity"]["output"]> {
    return await pyInvoke("get_events_by_activity", body, options);
}

/**
 * Delete activity by ID.
 *
 * Removes the activity from persistence and emits deletion event to frontend.
 *
 * @param body - Request parameters including activity ID.
 * @returns Deletion result with success flag and timestamp
 */
export async function deleteActivity(
    body: Commands["delete_activity"]["input"],
    options?: InvokeOptions
): Promise<Commands["delete_activity"]["output"]> {
    return await pyInvoke("delete_activity", body, options);
}

/**
 * Delete activities in date range.
 *
 * Soft deletes all activities that fall within the specified date range.
 *
 * @param body - Request parameters including start_date and end_date (YYYY-MM-DD format).
 * @returns Deletion result with count of deleted activities
 */
export async function deleteActivitiesByDate(
    body: Commands["delete_activities_by_date"]["input"],
    options?: InvokeOptions
): Promise<Commands["delete_activities_by_date"]["output"]> {
    return await pyInvoke("delete_activities_by_date", body, options);
}

/**
 * Merge multiple activities into a single activity
 *
 * Args:
 *     body: Merge request with activity IDs and merged content
 *
 * Returns:
 *     Response with merged activity ID or error
 */
export async function mergeActivitiesHandler(
    body: Commands["merge_activities_handler"]["input"],
    options?: InvokeOptions
): Promise<Commands["merge_activities_handler"]["output"]> {
    return await pyInvoke("merge_activities_handler", body, options);
}

/**
 * Split an activity into multiple activities
 *
 * Args:
 *     body: Split request with activity ID and split points
 *
 * Returns:
 *     Response with new activity IDs or error
 */
export async function splitActivityHandler(
    body: Commands["split_activity_handler"]["input"],
    options?: InvokeOptions
): Promise<Commands["split_activity_handler"]["output"]> {
    return await pyInvoke("split_activity_handler", body, options);
}

/**
 * Save or update an activity rating
 *
 * Supports multi-dimensional ratings:
 * - focus_level: How focused were you? (1-5)
 * - productivity: How productive was this session? (1-5)
 * - importance: How important was this activity? (1-5)
 * - satisfaction: How satisfied are you with the outcome? (1-5)
 */
export async function saveActivityRating(
    body: Commands["save_activity_rating"]["input"],
    options?: InvokeOptions
): Promise<Commands["save_activity_rating"]["output"]> {
    return await pyInvoke("save_activity_rating", body, options);
}

/**
 * Get all ratings for an activity
 *
 * Returns ratings for all dimensions that have been rated.
 */
export async function getActivityRatings(
    body: Commands["get_activity_ratings"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_activity_ratings"]["output"]> {
    return await pyInvoke("get_activity_ratings", body, options);
}

/**
 * Delete a specific activity rating
 *
 * Removes the rating for a specific dimension.
 */
export async function deleteActivityRating(
    body: Commands["delete_activity_rating"]["input"],
    options?: InvokeOptions
): Promise<Commands["delete_activity_rating"]["output"]> {
    return await pyInvoke("delete_activity_rating", body, options);
}

/**
 * Create new agent task
 */
export async function createTask(
    body: Commands["create_task"]["input"],
    options?: InvokeOptions
): Promise<Commands["create_task"]["output"]> {
    return await pyInvoke("create_task", body, options);
}

/**
 * Execute agent task
 */
export async function executeTask(
    body: Commands["execute_task"]["input"],
    options?: InvokeOptions
): Promise<Commands["execute_task"]["output"]> {
    return await pyInvoke("execute_task", body, options);
}

/**
 * Delete agent task
 */
export async function deleteTask(
    body: Commands["delete_task"]["input"],
    options?: InvokeOptions
): Promise<Commands["delete_task"]["output"]> {
    return await pyInvoke("delete_task", body, options);
}

/**
 * Get agent task list
 */
export async function getTasks(
    body: Commands["get_tasks"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_tasks"]["output"]> {
    return await pyInvoke("get_tasks", body, options);
}

/**
 * Get available agent list
 */
export async function getAvailableAgents(
    body: Commands["get_available_agents"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_available_agents"]["output"]> {
    return await pyInvoke("get_available_agents", body, options);
}

/**
 * Get task status
 */
export async function getTaskStatus(
    body: Commands["get_task_status"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_task_status"]["output"]> {
    return await pyInvoke("get_task_status", body, options);
}

/**
 * Schedule task to a specific date
 */
export async function scheduleTask(
    body: Commands["schedule_task"]["input"],
    options?: InvokeOptions
): Promise<Commands["schedule_task"]["output"]> {
    return await pyInvoke("schedule_task", body, options);
}

/**
 * Unschedule task (move back to pending)
 */
export async function unscheduleTask(
    body: Commands["unschedule_task"]["input"],
    options?: InvokeOptions
): Promise<Commands["unschedule_task"]["output"]> {
    return await pyInvoke("unschedule_task", body, options);
}

/**
 * Get tasks scheduled for a specific date
 */
export async function getTasksByDate(
    body: Commands["get_tasks_by_date"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_tasks_by_date"]["output"]> {
    return await pyInvoke("get_tasks_by_date", body, options);
}

/**
 * Execute task in chat
 */
export async function executeTaskInChat(
    body: Commands["execute_task_in_chat"]["input"],
    options?: InvokeOptions
): Promise<Commands["execute_task_in_chat"]["output"]> {
    return await pyInvoke("execute_task_in_chat", body, options);
}

/**
 * Create new conversation
 *
 * Args:
 *     body: Contains title, related activities and other information
 *
 * Returns:
 *     Created conversation information
 */
export async function createConversation(
    body: Commands["create_conversation"]["input"],
    options?: InvokeOptions
): Promise<Commands["create_conversation"]["output"]> {
    return await pyInvoke("create_conversation", body, options);
}

/**
 * Create conversation from activities, automatically generate context
 *
 * Args:
 *     body: Contains activity ID list
 *
 * Returns:
 *     Created conversation information and auto-generated context messages
 */
export async function createConversationFromActivities(
    body: Commands["create_conversation_from_activities"]["input"],
    options?: InvokeOptions
): Promise<Commands["create_conversation_from_activities"]["output"]> {
    return await pyInvoke("create_conversation_from_activities", body, options);
}

/**
 * Send message (streaming output)
 *
 * This endpoint starts streaming output, sending message blocks in real-time through Tauri Events.
 * The frontend should listen to 'chat-message-chunk' events to receive streaming content.
 * Supports multimodal messages (text + images).
 *
 * Args:
 *     body: Containing conversation ID, message content, and optional images
 *
 * Returns:
 *     Operation status
 */
export async function sendMessage(
    body: Commands["send_message"]["input"],
    options?: InvokeOptions
): Promise<Commands["send_message"]["output"]> {
    return await pyInvoke("send_message", body, options);
}

/**
 * Get conversation list
 *
 * Args:
 *     body: Contains pagination parameters
 *
 * Returns:
 *     Conversation list
 */
export async function getConversations(
    body: Commands["get_conversations"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_conversations"]["output"]> {
    return await pyInvoke("get_conversations", body, options);
}

/**
 * Get message list
 *
 * Args:
 *     body: Contains conversation ID and pagination parameters
 *
 * Returns:
 *     Message list
 */
export async function getMessages(
    body: Commands["get_messages"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_messages"]["output"]> {
    return await pyInvoke("get_messages", body, options);
}

/**
 * Delete conversation (cascade delete all messages)
 *
 * Args:
 *     body: Containing conversation ID
 *
 * Returns:
 *     Operation status
 */
export async function deleteConversation(
    body: Commands["delete_conversation"]["input"],
    options?: InvokeOptions
): Promise<Commands["delete_conversation"]["output"]> {
    return await pyInvoke("delete_conversation", body, options);
}

/**
 * Get streaming status for conversations
 *
 * Args:
 *     body: Optional list of conversation IDs to check. If None, returns all active streams.
 *
 * Returns:
 *     Dict containing:
 *     - activeStreams: List of conversation IDs that are currently streaming
 *     - streamingStatus: Dict mapping conversation_id -> boolean (whether it's streaming)
 */
export async function getStreamingStatus(
    body: Commands["get_streaming_status"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_streaming_status"]["output"]> {
    return await pyInvoke("get_streaming_status", body, options);
}

/**
 * Cancel streaming output for a conversation
 *
 * Args:
 *     body: Containing conversation ID
 *
 * Returns:
 *     Operation status
 */
export async function cancelStream(
    body: Commands["cancel_stream"]["input"],
    options?: InvokeOptions
): Promise<Commands["cancel_stream"]["output"]> {
    return await pyInvoke("cancel_stream", body, options);
}

/**
 * Get friendly chat configuration.
 *
 * Returns the current settings for the friendly chat feature including
 * interval, data window, and notification preferences.
 */
export async function getFriendlyChatSettings(
    body: Commands["get_friendly_chat_settings"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_friendly_chat_settings"]["output"]> {
    return await pyInvoke("get_friendly_chat_settings", body, options);
}

/**
 * Update friendly chat configuration.
 *
 * Updates the friendly chat settings and restarts the service if needed.
 */
export async function updateFriendlyChatSettings(
    body: Commands["update_friendly_chat_settings"]["input"],
    options?: InvokeOptions
): Promise<Commands["update_friendly_chat_settings"]["output"]> {
    return await pyInvoke("update_friendly_chat_settings", body, options);
}

/**
 * Get friendly chat message history.
 *
 * Returns a paginated list of previously generated chat messages.
 */
export async function getFriendlyChatHistory(
    body: Commands["get_friendly_chat_history"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_friendly_chat_history"]["output"]> {
    return await pyInvoke("get_friendly_chat_history", body, options);
}

/**
 * Manually trigger a friendly chat message generation.
 *
 * Generates and sends a chat message immediately based on recent activities.
 */
export async function triggerFriendlyChat(
    body: Commands["trigger_friendly_chat"]["input"],
    options?: InvokeOptions
): Promise<Commands["trigger_friendly_chat"]["output"]> {
    return await pyInvoke("trigger_friendly_chat", body, options);
}

/**
 * Get Live2D configuration.
 */
export async function getLive2DSettings(
    body: Commands["get_live2d_settings"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_live2d_settings"]["output"]> {
    return await pyInvoke("get_live2d_settings", body, options);
}

/**
 * Update Live2D configuration values.
 */
export async function updateLive2DSettings(
    body: Commands["update_live2d_settings"]["input"],
    options?: InvokeOptions
): Promise<Commands["update_live2d_settings"]["output"]> {
    return await pyInvoke("update_live2d_settings", body, options);
}

/**
 * Get processed events with optional filters.
 *
 * Args:
 *     body: Request parameters including limit and filters.
 *
 * Returns:
 *     Events data with success flag and timestamp
 */
export async function getEvents(
    body: Commands["get_events"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_events"]["output"]> {
    return await pyInvoke("get_events", body, options);
}

/**
 * Get event details by ID.
 *
 * Args:
 *     body: Request parameters including event ID.
 *
 * Returns:
 *     Event details with success flag and timestamp
 */
export async function getEventById(
    body: Commands["get_event_by_id"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_event_by_id"]["output"]> {
    return await pyInvoke("get_event_by_id", body, options);
}

/**
 * Get all actions for a specific event (three-layer drill-down).
 *
 * Args:
 *     body: Request containing event_id
 *
 * Returns:
 *     Response with list of actions including screenshots
 */
export async function getActionsByEvent(
    body: Commands["get_actions_by_event"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_actions_by_event"]["output"]> {
    return await pyInvoke("get_actions_by_event", body, options);
}

/**
 * Delete event by ID.
 *
 * Removes the event from persistence and emits deletion event to frontend.
 *
 * Args:
 *     body: Request parameters including event ID.
 *
 * Returns:
 *     Deletion result with success flag and timestamp
 */
export async function deleteEvent(
    body: Commands["delete_event"]["input"],
    options?: InvokeOptions
): Promise<Commands["delete_event"]["output"]> {
    return await pyInvoke("delete_event", body, options);
}

/**
 * Get all actions for a specific activity (action-based aggregation drill-down).
 *
 * Args:
 *     body: Request containing event_id (but we'll use it as activity_id)
 *
 * Returns:
 *     Response with list of actions including screenshots
 */
export async function getActionsByActivity(
    body: Commands["get_actions_by_activity"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_actions_by_activity"]["output"]> {
    return await pyInvoke("get_actions_by_activity", body, options);
}

/**
 * Get recent events
 *
 * @param body - Request parameters including limit and offset
 * @returns Event list and metadata
 */
export async function getRecentEvents(
    body: Commands["get_recent_events"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_recent_events"]["output"]> {
    return await pyInvoke("get_recent_events", body, options);
}

/**
 * Get knowledge list
 *
 * @returns Knowledge list
 */
export async function getKnowledgeList(
    body: Commands["get_knowledge_list"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_knowledge_list"]["output"]> {
    return await pyInvoke("get_knowledge_list", body, options);
}

/**
 * Delete knowledge (soft delete)
 *
 * @param body - Contains knowledge ID to delete
 * @returns Deletion result
 */
export async function deleteKnowledge(
    body: Commands["delete_knowledge"]["input"],
    options?: InvokeOptions
): Promise<Commands["delete_knowledge"]["output"]> {
    return await pyInvoke("delete_knowledge", body, options);
}

/**
 * Toggle knowledge favorite status
 *
 * @param body - Contains knowledge ID
 * @returns Updated knowledge data with new favorite status
 */
export async function toggleKnowledgeFavorite(
    body: Commands["toggle_knowledge_favorite"]["input"],
    options?: InvokeOptions
): Promise<Commands["toggle_knowledge_favorite"]["output"]> {
    return await pyInvoke("toggle_knowledge_favorite", body, options);
}

/**
 * Create knowledge manually
 *
 * @param body - Contains title, description, and keywords
 * @returns Created knowledge data
 */
export async function createKnowledge(
    body: Commands["create_knowledge"]["input"],
    options?: InvokeOptions
): Promise<Commands["create_knowledge"]["output"]> {
    return await pyInvoke("create_knowledge", body, options);
}

/**
 * Get todo list
 *
 * @param body - Request parameters, include include_completed
 * @returns Todo list
 */
export async function getTodoList(
    body: Commands["get_todo_list"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_todo_list"]["output"]> {
    return await pyInvoke("get_todo_list", body, options);
}

/**
 * Delete todo (soft delete)
 *
 * @param body - Contains todo ID to delete
 * @returns Deletion result
 */
export async function deleteTodo(
    body: Commands["delete_todo"]["input"],
    options?: InvokeOptions
): Promise<Commands["delete_todo"]["output"]> {
    return await pyInvoke("delete_todo", body, options);
}

/**
 * Schedule todo to a specific date
 *
 * @param body - Contains todo ID, scheduled date, optional time, end time, and recurrence rule
 * @returns Updated todo
 */
export async function scheduleTodo(
    body: Commands["schedule_todo"]["input"],
    options?: InvokeOptions
): Promise<Commands["schedule_todo"]["output"]> {
    return await pyInvoke("schedule_todo", body, options);
}

/**
 * Unschedule todo
 *
 * @param body - Contains todo ID
 * @returns Updated todo
 */
export async function unscheduleTodo(
    body: Commands["unschedule_todo"]["input"],
    options?: InvokeOptions
): Promise<Commands["unschedule_todo"]["output"]> {
    return await pyInvoke("unschedule_todo", body, options);
}

/**
 * Generate diary
 *
 * @param body - Contains date (YYYY-MM-DD format)
 * @returns Generated diary content
 */
export async function generateDiary(
    body: Commands["generate_diary"]["input"],
    options?: InvokeOptions
): Promise<Commands["generate_diary"]["output"]> {
    return await pyInvoke("generate_diary", body, options);
}

/**
 * Get diary list
 */
export async function getDiaryList(
    body: Commands["get_diary_list"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_diary_list"]["output"]> {
    return await pyInvoke("get_diary_list", body, options);
}

/**
 * Delete diary
 *
 * @param body - Contains the diary ID to delete
 * @returns Deletion result
 */
export async function deleteDiary(
    body: Commands["delete_diary"]["input"],
    options?: InvokeOptions
): Promise<Commands["delete_diary"]["output"]> {
    return await pyInvoke("delete_diary", body, options);
}

/**
 * Get pipeline statistics
 *
 * @returns pipeline runtime status and statistics data
 */
export async function getPipelineStats(
    body: Commands["get_pipeline_stats"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_pipeline_stats"]["output"]> {
    return await pyInvoke("get_pipeline_stats", body, options);
}

/**
 * Get event count grouped by date
 *
 * @returns Event count statistics by date
 */
export async function getEventCountByDate(
    body: Commands["get_event_count_by_date"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_event_count_by_date"]["output"]> {
    return await pyInvoke("get_event_count_by_date", body, options);
}

/**
 * Get knowledge count grouped by date
 *
 * @returns Knowledge count statistics by date
 */
export async function getKnowledgeCountByDate(
    body: Commands["get_knowledge_count_by_date"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_knowledge_count_by_date"]["output"]> {
    return await pyInvoke("get_knowledge_count_by_date", body, options);
}

/**
 * Get available monitors information.
 *
 * Returns information about all available monitors including resolution and position.
 *
 * @returns Monitors data with success flag and timestamp
 */
export async function getMonitors(
    body: Commands["get_monitors"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_monitors"]["output"]> {
    return await pyInvoke("get_monitors", body, options);
}

/**
 * Start background auto-refresh for monitors detection.
 *
 * Body:
 *   - interval_seconds: float (optional, default 10.0)
 */
export async function startMonitorsAutoRefresh(
    body: Commands["start_monitors_auto_refresh"]["input"],
    options?: InvokeOptions
): Promise<Commands["start_monitors_auto_refresh"]["output"]> {
    return await pyInvoke("start_monitors_auto_refresh", body, options);
}

/**
 * Stop background auto-refresh for monitors detection.
 */
export async function stopMonitorsAutoRefresh(
    body: Commands["stop_monitors_auto_refresh"]["input"],
    options?: InvokeOptions
): Promise<Commands["stop_monitors_auto_refresh"]["output"]> {
    return await pyInvoke("stop_monitors_auto_refresh", body, options);
}

/**
 * Get background auto-refresh status.
 */
export async function getMonitorsAutoRefreshStatus(
    body: Commands["get_monitors_auto_refresh_status"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_monitors_auto_refresh_status"]["output"]> {
    return await pyInvoke("get_monitors_auto_refresh_status", body, options);
}

/**
 * Get screen capture settings.
 *
 * Returns current screen capture settings from config.
 */
export async function getScreenSettings(
    body: Commands["get_screen_settings"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_screen_settings"]["output"]> {
    return await pyInvoke("get_screen_settings", body, options);
}

/**
 * Capture preview thumbnails for all monitors.
 *
 * Generates small preview images for all connected monitors to help users
 * identify which screen is which when configuring screenshot settings.
 */
export async function captureAllPreviews(
    body: Commands["capture_all_previews"]["input"],
    options?: InvokeOptions
): Promise<Commands["capture_all_previews"]["output"]> {
    return await pyInvoke("capture_all_previews", body, options);
}

/**
 * Update screen capture settings.
 *
 * Updates which screens should be captured for screenshots.
 */
export async function updateScreenSettings(
    body: Commands["update_screen_settings"]["input"],
    options?: InvokeOptions
): Promise<Commands["update_screen_settings"]["output"]> {
    return await pyInvoke("update_screen_settings", body, options);
}

/**
 * Get perception settings.
 *
 * Returns current keyboard and mouse perception settings.
 */
export async function getPerceptionSettings(
    body: Commands["get_perception_settings"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_perception_settings"]["output"]> {
    return await pyInvoke("get_perception_settings", body, options);
}

/**
 * Update perception settings.
 *
 * Updates which perception inputs (keyboard/mouse) should be monitored.
 */
export async function updatePerceptionSettings(
    body: Commands["update_perception_settings"]["input"],
    options?: InvokeOptions
): Promise<Commands["update_perception_settings"]["output"]> {
    return await pyInvoke("update_perception_settings", body, options);
}

/**
 * Get perception module statistics.
 *
 * Returns statistics about the perception module including record counts and status.
 *
 * @returns Statistics data with success flag and timestamp
 */
export async function getPerceptionStats(
    body: Commands["get_perception_stats"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_perception_stats"]["output"]> {
    return await pyInvoke("get_perception_stats", body, options);
}

/**
 * Get perception records with optional filters.
 *
 * @param body - Request parameters including limit and filters.
 * @returns Records data with success flag and timestamp
 */
export async function getRecords(
    body: Commands["get_records"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_records"]["output"]> {
    return await pyInvoke("get_records", body, options);
}

/**
 * Start the perception module.
 *
 * Starts monitoring keyboard, mouse, and screenshots.
 *
 * @returns Success response with message and timestamp
 */
export async function startPerception(
    body: Commands["start_perception"]["input"],
    options?: InvokeOptions
): Promise<Commands["start_perception"]["output"]> {
    return await pyInvoke("start_perception", body, options);
}

/**
 * Stop the perception module.
 *
 * Stops monitoring keyboard, mouse, and screenshots.
 *
 * @returns Success response with message and timestamp
 */
export async function stopPerception(
    body: Commands["stop_perception"]["input"],
    options?: InvokeOptions
): Promise<Commands["stop_perception"]["output"]> {
    return await pyInvoke("stop_perception", body, options);
}

/**
 * Clear all perception records.
 *
 * Removes all stored records and clears the buffer.
 *
 * @returns Success response with message and timestamp
 */
export async function clearRecords(
    body: Commands["clear_records"]["input"],
    options?: InvokeOptions
): Promise<Commands["clear_records"]["output"]> {
    return await pyInvoke("clear_records", body, options);
}

/**
 * Get buffered events.
 *
 * Returns events currently in the buffer waiting to be processed.
 *
 * @returns Buffered events data with success flag and timestamp
 */
export async function getBufferedEvents(
    body: Commands["get_buffered_events"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_buffered_events"]["output"]> {
    return await pyInvoke("get_buffered_events", body, options);
}

/**
 * Check all required system permissions
 *
 * Returns:
 *     Permission check results, including status of each permission
 */
export async function checkPermissions(
    body: Commands["check_permissions"]["input"],
    options?: InvokeOptions
): Promise<Commands["check_permissions"]["output"]> {
    return await pyInvoke("check_permissions", body, options);
}

/**
 * Open system settings permission page
 *
 * Args:
 *     body: Contains the permission type to open
 *
 * Returns:
 *     Operation result
 */
export async function openSystemSettings(
    body: Commands["open_system_settings"]["input"],
    options?: InvokeOptions
): Promise<Commands["open_system_settings"]["output"]> {
    return await pyInvoke("open_system_settings", body, options);
}

/**
 * Request accessibility permission (macOS only)
 *
 * This will trigger system permission dialog
 *
 * Returns:
 *     Request result
 */
export async function requestAccessibilityPermission(
    body: Commands["request_accessibility_permission"]["input"],
    options?: InvokeOptions
): Promise<Commands["request_accessibility_permission"]["output"]> {
    return await pyInvoke("request_accessibility_permission", body, options);
}

/**
 * Restart application
 *
 * Args:
 *     body: Request containing delay time
 *
 * Returns:
 *     Operation result
 */
export async function restartApp(
    body: Commands["restart_app"]["input"],
    options?: InvokeOptions
): Promise<Commands["restart_app"]["output"]> {
    return await pyInvoke("restart_app", body, options);
}

/**
 * Start a new Pomodoro session
 *
 * Args:
 *     body: Request containing user_intent and duration_minutes
 *
 * Returns:
 *     StartPomodoroResponse with session data
 *
 * Raises:
 *     ValueError: If a Pomodoro session is already active or previous session is still processing
 */
export async function startPomodoro(
    body: Commands["start_pomodoro"]["input"],
    options?: InvokeOptions
): Promise<Commands["start_pomodoro"]["output"]> {
    return await pyInvoke("start_pomodoro", body, options);
}

/**
 * End current Pomodoro session
 *
 * Args:
 *     body: Request containing status (completed/abandoned/interrupted)
 *
 * Returns:
 *     EndPomodoroResponse with processing job info
 *
 * Raises:
 *     ValueError: If no active Pomodoro session
 */
export async function endPomodoro(
    body: Commands["end_pomodoro"]["input"],
    options?: InvokeOptions
): Promise<Commands["end_pomodoro"]["output"]> {
    return await pyInvoke("end_pomodoro", body, options);
}

/**
 * Get current Pomodoro session status
 *
 * Returns:
 *     GetPomodoroStatusResponse with current session info or None if no active session
 */
export async function getPomodoroStatus(
    body: Commands["get_pomodoro_status"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_pomodoro_status"]["output"]> {
    return await pyInvoke("get_pomodoro_status", body, options);
}

/**
 * Manually trigger work phase activity aggregation (for retry)
 *
 * This endpoint allows users to manually retry activity aggregation for a specific
 * work phase if the automatic aggregation failed or was incomplete.
 *
 * Args:
 *     body: Request containing session_id and work_phase number
 *
 * Returns:
 *     EndPomodoroResponse with success status and processing details
 */
export async function retryWorkPhaseAggregation(
    body: Commands["retry_work_phase_aggregation"]["input"],
    options?: InvokeOptions
): Promise<Commands["retry_work_phase_aggregation"]["output"]> {
    return await pyInvoke("retry_work_phase_aggregation", body, options);
}

/**
 * Find activities that overlap with session time but aren't linked
 *
 * Returns list of activities that could be retroactively linked
 */
export async function findUnlinkedActivities(
    body: Commands["find_unlinked_activities"]["input"],
    options?: InvokeOptions
): Promise<Commands["find_unlinked_activities"]["output"]> {
    return await pyInvoke("find_unlinked_activities", body, options);
}

/**
 * Link selected activities to a Pomodoro session
 *
 * Updates activity records with pomodoro_session_id and auto-categorizes
 * work_phase based on the activity's time period
 */
export async function linkActivitiesToSession(
    body: Commands["link_activities_to_session"]["input"],
    options?: InvokeOptions
): Promise<Commands["link_activities_to_session"]["output"]> {
    return await pyInvoke("link_activities_to_session", body, options);
}

/**
 * Get available Pomodoro configuration presets
 *
 * Returns a list of predefined configurations including:
 * - Classic Pomodoro (25/5)
 * - Deep Work (50/10)
 * - Quick Sprint (15/3)
 * - Ultra Focus (90/15)
 * - Balanced Flow (40/8)
 */
export async function getPomodoroPresets(
    body: Commands["get_pomodoro_presets"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_pomodoro_presets"]["output"]> {
    return await pyInvoke("get_pomodoro_presets", body, options);
}

/**
 * Get Pomodoro statistics for a specific date
 *
 * Returns:
 * - Number of completed sessions
 * - Total focus time (minutes)
 * - Average session duration (minutes)
 * - List of all sessions for that day
 */
export async function getPomodoroStats(
    body: Commands["get_pomodoro_stats"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_pomodoro_stats"]["output"]> {
    return await pyInvoke("get_pomodoro_stats", body, options);
}

/**
 * Get detailed Pomodoro session with activities and focus metrics
 *
 * Returns:
 * - Full session data
 * - All activities generated during this session (ordered by work phase)
 * - Calculated focus metrics (overall_focus_score, activity_count, topic_diversity, etc.)
 */
export async function getPomodoroSessionDetail(
    body: Commands["get_pomodoro_session_detail"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_pomodoro_session_detail"]["output"]> {
    return await pyInvoke("get_pomodoro_session_detail", body, options);
}

/**
 * Get Pomodoro statistics for a time period (week/month/year)
 *
 * Returns:
 * - Period summary statistics (total sessions, focus hours, daily average, completion rate)
 * - Daily breakdown data for visualization
 */
export async function getPomodoroPeriodStats(
    body: Commands["get_pomodoro_period_stats"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_pomodoro_period_stats"]["output"]> {
    return await pyInvoke("get_pomodoro_period_stats", body, options);
}

/**
 * Delete a Pomodoro session and cascade delete all linked activities
 *
 * This operation:
 * 1. Validates session exists and is not already deleted
 * 2. Soft deletes all activities linked to this session (cascade)
 * 3. Soft deletes the session itself
 * 4. Emits deletion event to notify frontend
 *
 * Args:
 *     body: Request containing session_id
 *
 * Returns:
 *     Response with deletion result and count of cascade-deleted activities
 */
export async function deletePomodoroSession(
    body: Commands["delete_pomodoro_session"]["input"],
    options?: InvokeOptions
): Promise<Commands["delete_pomodoro_session"]["output"]> {
    return await pyInvoke("delete_pomodoro_session", body, options);
}

/**
 * Get processing module statistics.
 *
 * Returns statistics about event and activity processing.
 *
 * @returns Statistics data with success flag and timestamp
 */
export async function getProcessingStats(
    body: Commands["get_processing_stats"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_processing_stats"]["output"]> {
    return await pyInvoke("get_processing_stats", body, options);
}

/**
 * Get persistence statistics.
 *
 * Returns statistics about data persistence including database size, screenshot storage, and record counts.
 *
 * @returns Statistics data with success flag and timestamp
 */
export async function getPersistenceStats(
    body: Commands["get_persistence_stats"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_persistence_stats"]["output"]> {
    return await pyInvoke("get_persistence_stats", body, options);
}

/**
 * Start the processing pipeline.
 *
 * Begins processing raw records into events and activities.
 *
 * @returns Success response with message and timestamp
 */
export async function startProcessing(
    body: Commands["start_processing"]["input"],
    options?: InvokeOptions
): Promise<Commands["start_processing"]["output"]> {
    return await pyInvoke("start_processing", body, options);
}

/**
 * Stop the processing pipeline.
 *
 * Stops processing raw records.
 *
 * @returns Success response with message and timestamp
 */
export async function stopProcessing(
    body: Commands["stop_processing"]["input"],
    options?: InvokeOptions
): Promise<Commands["stop_processing"]["output"]> {
    return await pyInvoke("stop_processing", body, options);
}

/**
 * Force finalize the current activity.
 *
 * Forces the completion of the current activity being processed.
 *
 * @returns Success response with message and timestamp
 */
export async function finalizeCurrentActivity(
    body: Commands["finalize_current_activity"]["input"],
    options?: InvokeOptions
): Promise<Commands["finalize_current_activity"]["output"]> {
    return await pyInvoke("finalize_current_activity", body, options);
}

/**
 * Clean up old data.
 *
 * Deletes activities, events, and other data older than specified days.
 *
 * @param body - Request parameters including number of days to keep.
 * @returns Cleanup result with success flag and timestamp
 */
export async function cleanupOldData(
    body: Commands["cleanup_old_data"]["input"],
    options?: InvokeOptions
): Promise<Commands["cleanup_old_data"]["output"]> {
    return await pyInvoke("cleanup_old_data", body, options);
}

/**
 * Clean up orphaned screenshot images.
 *
 * Removes screenshot images that are not referenced by any action.
 * Only removes images older than 30 minutes to avoid deleting images being processed.
 *
 * @returns Cleanup result with count of deleted images
 */
export async function cleanupOrphanedImages(
    body: Commands["cleanup_orphaned_images"]["input"],
    options?: InvokeOptions
): Promise<Commands["cleanup_orphaned_images"]["output"]> {
    return await pyInvoke("cleanup_orphaned_images", body, options);
}

/**
 * Delete knowledge in date range.
 *
 * Soft deletes all knowledge that fall within the specified date range.
 *
 * @param body - Request parameters including start_date and end_date (YYYY-MM-DD format).
 * @returns Deletion result with count of deleted knowledge records
 */
export async function deleteKnowledgeByDate(
    body: Commands["delete_knowledge_by_date"]["input"],
    options?: InvokeOptions
): Promise<Commands["delete_knowledge_by_date"]["output"]> {
    return await pyInvoke("delete_knowledge_by_date", body, options);
}

/**
 * Delete todos in date range.
 *
 * Soft deletes all todos that fall within the specified date range.
 *
 * @param body - Request parameters including start_date and end_date (YYYY-MM-DD format).
 * @returns Deletion result with count of deleted todo records
 */
export async function deleteTodosByDate(
    body: Commands["delete_todos_by_date"]["input"],
    options?: InvokeOptions
): Promise<Commands["delete_todos_by_date"]["output"]> {
    return await pyInvoke("delete_todos_by_date", body, options);
}

/**
 * Delete diaries in date range.
 *
 * Soft deletes all diaries that fall within the specified date range.
 *
 * @param body - Request parameters including start_date and end_date (YYYY-MM-DD format).
 * @returns Deletion result with count of deleted diary records
 */
export async function deleteDiariesByDate(
    body: Commands["delete_diaries_by_date"]["input"],
    options?: InvokeOptions
): Promise<Commands["delete_diaries_by_date"]["output"]> {
    return await pyInvoke("delete_diaries_by_date", body, options);
}

/**
 * Get image cache statistics
 *
 * Returns:
 *     Image cache and disk usage statistics
 */
export async function getImageStats(
    body: Commands["get_image_stats"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_image_stats"]["output"]> {
    return await pyInvoke("get_image_stats", body, options);
}

/**
 * Batch get images from memory (base64 format)
 *
 * Args:
 *     body: Request containing image hash list
 *
 * Returns:
 *     Response containing base64 image data
 */
export async function getCachedImages(
    body: Commands["get_cached_images"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_cached_images"]["output"]> {
    return await pyInvoke("get_cached_images", body, options);
}

/**
 * Clean up old image files
 *
 * Args:
 *     body: Request containing maximum retention time
 *
 * Returns:
 *     Cleanup result statistics
 */
export async function cleanupOldImages(
    body: Commands["cleanup_old_images"]["input"],
    options?: InvokeOptions
): Promise<Commands["cleanup_old_images"]["output"]> {
    return await pyInvoke("cleanup_old_images", body, options);
}

/**
 * Clear memory cache
 *
 * Returns:
 *     Cleanup result
 */
export async function clearMemoryCache(
    body: Commands["clear_memory_cache"]["input"],
    options?: InvokeOptions
): Promise<Commands["clear_memory_cache"]["output"]> {
    return await pyInvoke("clear_memory_cache", body, options);
}

/**
 * Get image optimization configuration
 *
 * @returns Current image optimization configuration
 */
export async function getImageOptimizationConfig(
    body: Commands["get_image_optimization_config"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_image_optimization_config"]["output"]> {
    return await pyInvoke("get_image_optimization_config", body, options);
}

/**
 * Get image optimization statistics
 *
 * Returns:
 *     Information including sampling statistics, skip reason distribution, etc.
 */
export async function getImageOptimizationStats(
    body: Commands["get_image_optimization_stats"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_image_optimization_stats"]["output"]> {
    return await pyInvoke("get_image_optimization_stats", body, options);
}

/**
 * Update image optimization configuration
 *
 * @param body Contains image optimization configuration items to update
 * @returns Success response with updated configuration
 */
export async function updateImageOptimizationConfig(
    body: Commands["update_image_optimization_config"]["input"],
    options?: InvokeOptions
): Promise<Commands["update_image_optimization_config"]["output"]> {
    return await pyInvoke("update_image_optimization_config", body, options);
}

/**
 * Read image file and return as base64 encoded data URL
 *
 * Args:
 *     body: Request containing file path
 *
 * Returns:
 *     Response with base64 data URL
 */
export async function readImageFile(
    body: Commands["read_image_file"]["input"],
    options?: InvokeOptions
): Promise<Commands["read_image_file"]["output"]> {
    return await pyInvoke("read_image_file", body, options);
}

/**
 * Check health of image persistence system
 *
 * Analyzes all actions with screenshots to determine how many have missing
 * image files on disk. Provides statistics for diagnostics.
 *
 * Returns:
 *     Health check results with statistics
 */
export async function checkImagePersistenceHealth(
    body: Commands["check_image_persistence_health"]["input"],
    options?: InvokeOptions
): Promise<Commands["check_image_persistence_health"]["output"]> {
    return await pyInvoke("check_image_persistence_health", body, options);
}

/**
 * Clean up actions with missing image references
 *
 * Supports three strategies:
 * - delete_actions: Soft-delete actions with all images missing
 * - remove_references: Clear image references, keep action metadata
 * - dry_run: Report what would be cleaned without making changes
 *
 * Args:
 *     body: Cleanup request with strategy and optional action IDs
 *
 * Returns:
 *     Cleanup results with statistics
 */
export async function cleanupBrokenActionImages(
    body: Commands["cleanup_broken_action_images"]["input"],
    options?: InvokeOptions
): Promise<Commands["cleanup_broken_action_images"]["output"]> {
    return await pyInvoke("cleanup_broken_action_images", body, options);
}

/**
 * Create new model configuration
 *
 * @param body Model configuration information (includes API key)
 * @returns Created model information
 */
export async function createModel(
    body: Commands["create_model"]["input"],
    options?: InvokeOptions
): Promise<Commands["create_model"]["output"]> {
    return await pyInvoke("create_model", body, options);
}

/**
 * Update model configuration
 *
 * @param body Model information to update (only update provided fields)
 * @returns Updated model information
 */
export async function updateModel(
    body: Commands["update_model"]["input"],
    options?: InvokeOptions
): Promise<Commands["update_model"]["output"]> {
    return await pyInvoke("update_model", body, options);
}

/**
 * Delete model configuration
 *
 * @param body Model ID to delete
 * @returns Deletion result
 */
export async function deleteModel(
    body: Commands["delete_model"]["input"],
    options?: InvokeOptions
): Promise<Commands["delete_model"]["output"]> {
    return await pyInvoke("delete_model", body, options);
}

/**
 * Get all model configuration list
 *
 * @returns Model list (without API keys)
 */
export async function listModels(
    body: Commands["list_models"]["input"],
    options?: InvokeOptions
): Promise<Commands["list_models"]["output"]> {
    return await pyInvoke("list_models", body, options);
}

/**
 * Get currently active model information
 *
 * @returns Active model detailed information (without API key)
 */
export async function getActiveModel(
    body: Commands["get_active_model"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_active_model"]["output"]> {
    return await pyInvoke("get_active_model", body, options);
}

/**
 * Select/activate specified model
 *
 * @param body Contains the model ID to activate
 * @returns Activation result and new model information
 */
export async function selectModel(
    body: Commands["select_model"]["input"],
    options?: InvokeOptions
): Promise<Commands["select_model"]["output"]> {
    return await pyInvoke("select_model", body, options);
}

/**
 * Test if the specified model's API connection is available
 */
export async function testModel(
    body: Commands["test_model"]["input"],
    options?: InvokeOptions
): Promise<Commands["test_model"]["output"]> {
    return await pyInvoke("test_model", body, options);
}

/**
 * Migrate all existing models to use 'openai' provider.
 *
 * This is a one-time migration to standardize all models to OpenAI-compatible format.
 *
 * @returns Migration result with count of updated models
 */
export async function migrateModelsToOpenai(
    body: Commands["migrate_models_to_openai"]["input"],
    options?: InvokeOptions
): Promise<Commands["migrate_models_to_openai"]["output"]> {
    return await pyInvoke("migrate_models_to_openai", body, options);
}

/**
 * Get LLM usage statistics
 *
 * @returns LLM token consumption statistics and call count
 */
export async function getLlmStats(
    body: Commands["get_llm_stats"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_llm_stats"]["output"]> {
    return await pyInvoke("get_llm_stats", body, options);
}

/**
 * Get LLM usage statistics by model
 */
export async function getLlmStatsByModel(
    body: Commands["get_llm_stats_by_model"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_llm_stats_by_model"]["output"]> {
    return await pyInvoke("get_llm_stats_by_model", body, options);
}

/**
 * Record LLM usage statistics
 *
 * @param body LLM usage information
 * @returns Recording result
 */
export async function recordLlmUsage(
    body: Commands["record_llm_usage"]["input"],
    options?: InvokeOptions
): Promise<Commands["record_llm_usage"]["output"]> {
    return await pyInvoke("record_llm_usage", body, options);
}

/**
 * Get overall usage summary statistics
 *
 * @returns Overall summary including activities, tasks, and LLM usage
 */
export async function getUsageSummary(
    body: Commands["get_usage_summary"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_usage_summary"]["output"]> {
    return await pyInvoke("get_usage_summary", body, options);
}

/**
 * Get daily LLM usage
 *
 * @returns Daily LLM usage data list
 */
export async function getDailyLlmUsage(
    body: Commands["get_daily_llm_usage"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_daily_llm_usage"]["output"]> {
    return await pyInvoke("get_daily_llm_usage", body, options);
}

/**
 * Get model usage distribution statistics
 *
 * @returns Model usage distribution data
 */
export async function getModelDistribution(
    body: Commands["get_model_distribution"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_model_distribution"]["output"]> {
    return await pyInvoke("get_model_distribution", body, options);
}

/**
 * Get LLM usage trend data with configurable time dimension
 *
 * @param body Request parameters including dimension (day/week/month), days range, and optional model filter
 * @returns Trend data points with date, tokens, calls, and cost
 */
export async function getLlmUsageTrend(
    body: Commands["get_llm_usage_trend"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_llm_usage_trend"]["output"]> {
    return await pyInvoke("get_llm_usage_trend", body, options);
}

/**
 * Start the entire backend system (perception + processing)
 *
 * @returns Success response with message and timestamp
 */
export async function startSystem(
    body: Commands["start_system"]["input"],
    options?: InvokeOptions
): Promise<Commands["start_system"]["output"]> {
    return await pyInvoke("start_system", body, options);
}

/**
 * Stop the entire backend system
 *
 * @returns Success response with message and timestamp
 */
export async function stopSystem(
    body: Commands["stop_system"]["input"],
    options?: InvokeOptions
): Promise<Commands["stop_system"]["output"]> {
    return await pyInvoke("stop_system", body, options);
}

/**
 * Get overall system status
 *
 * @returns System statistics with perception and processing info
 */
export async function getSystemStats(
    body: Commands["get_system_stats"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_system_stats"]["output"]> {
    return await pyInvoke("get_system_stats", body, options);
}

/**
 * Get the absolute path of the database being used by the backend
 */
export async function getDatabasePath(
    body: Commands["get_database_path"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_database_path"]["output"]> {
    return await pyInvoke("get_database_path", body, options);
}

/**
 * Get all application configurations
 *
 * Note: LLM configuration has been migrated to multi-model management system
 * See get_active_model() in models_management.py
 *
 * @returns Application configuration information
 */
export async function getSettingsInfo(
    body: Commands["get_settings_info"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_settings_info"]["output"]> {
    return await pyInvoke("get_settings_info", body, options);
}

/**
 * Update application configuration
 *
 * Note: LLM configuration has been migrated to multi-model management system
 * See create_model() and select_model() in models_management.py
 *
 * @param body Contains configuration items to update
 * @returns Update result
 */
export async function updateSettings(
    body: Commands["update_settings"]["input"],
    options?: InvokeOptions
): Promise<Commands["update_settings"]["output"]> {
    return await pyInvoke("update_settings", body, options);
}

/**
 * Get image compression configuration
 *
 * @returns Image compression configuration information
 */
export async function getImageCompressionConfig(
    body: Commands["get_image_compression_config"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_image_compression_config"]["output"]> {
    return await pyInvoke("get_image_compression_config", body, options);
}

/**
 * Update image compression configuration
 *
 * @param body Contains image compression configuration items to update
 * @returns Success response with updated configuration
 */
export async function updateImageCompressionConfig(
    body: Commands["update_image_compression_config"]["input"],
    options?: InvokeOptions
): Promise<Commands["update_image_compression_config"]["output"]> {
    return await pyInvoke("update_image_compression_config", body, options);
}

/**
 * Get image compression statistics
 *
 * @returns Image compression statistics data
 */
export async function getImageCompressionStats(
    body: Commands["get_image_compression_stats"]["input"],
    options?: InvokeOptions
): Promise<Commands["get_image_compression_stats"]["output"]> {
    return await pyInvoke("get_image_compression_stats", body, options);
}

/**
 * Reset image compression statistics
 *
 * @returns Success response
 */
export async function resetImageCompressionStats(
    body: Commands["reset_image_compression_stats"]["input"],
    options?: InvokeOptions
): Promise<Commands["reset_image_compression_stats"]["output"]> {
    return await pyInvoke("reset_image_compression_stats", body, options);
}

/**
 * Check if initial setup is required
 *
 * Returns status indicating whether the application needs initial configuration:
 * - has_models: Whether any LLM models are configured
 * - has_active_model: Whether an active model is selected
 * - has_completed_setup: Whether user has completed the initial setup flow
 * - needs_setup: Whether initial setup flow should be shown
 *
 * @returns Setup status with detailed configuration state
 */
export async function checkInitialSetup(
    body: Commands["check_initial_setup"]["input"],
    options?: InvokeOptions
): Promise<Commands["check_initial_setup"]["output"]> {
    return await pyInvoke("check_initial_setup", body, options);
}

/**
 * Mark initial setup as completed
 *
 * Persists the setup completion status in the settings table.
 * Once marked as completed, the welcome flow won't show again
 * unless the setting is manually reset.
 *
 * @returns Success status
 */
export async function completeInitialSetup(
    body: Commands["complete_initial_setup"]["input"],
    options?: InvokeOptions
): Promise<Commands["complete_initial_setup"]["output"]> {
    return await pyInvoke("complete_initial_setup", body, options);
}

/**
 * Update system tray menu labels with i18n translations.
 *
 * Note: Due to Tauri limitations, dynamic menu updates require
 * rebuilding the entire menu. This is currently handled in Rust.
 * This handler serves as a placeholder for future enhancements.
 *
 * Args:
 *     body: Translation strings for menu items
 *
 * Returns:
 *     Success status and message
 */
export async function updateTrayMenu(
    body: Commands["update_tray_menu"]["input"],
    options?: InvokeOptions
): Promise<Commands["update_tray_menu"]["output"]> {
    return await pyInvoke("update_tray_menu", body, options);
}

/**
 * Show or hide the system tray icon.
 *
 * Note: Tauri 2.x doesn't support hiding/showing tray icons after creation.
 * This is a placeholder for documentation purposes.
 *
 * Args:
 *     body: Visibility state
 *
 * Returns:
 *     Success status and current visibility
 */
export async function setTrayVisibility(
    body: Commands["set_tray_visibility"]["input"],
    options?: InvokeOptions
): Promise<Commands["set_tray_visibility"]["output"]> {
    return await pyInvoke("set_tray_visibility", body, options);
}

/**
 * A simple demo command that returns a greeting message.
 *
 * @param body - The person to greet.
 */
export async function greeting(
    body: Commands["greeting"]["input"],
    options?: InvokeOptions
): Promise<Commands["greeting"]["output"]> {
    return await pyInvoke("greeting", body, options);
}
